/*
 * Copyright (c) 2006 The Trustees of Indiana University and Indiana
 *                    University Research and Technology
 *                    Corporation.  All rights reserved.
 * Copyright (c) 2006 The Technical University of Chemnitz. All 
 *                    rights reserved.
 *
 * Author(s): Torsten Hoefler <htor@cs.indiana.edu>
 *
 */
#include "nbc.h"

/****************** THIS FILE is automatically generated *********************
 * changes will be deleted at the next generation of this file - see nbc_op.c.m4 */

typedef unsigned IdxType;

struct stream {
  unsigned nofitems;
  char items[];
};

void sum_d_streams(const struct stream *first_s, const struct stream *second_s, struct stream *result_s, unsigned dim, int forceDense) {

    unsigned p1 = 0;
    unsigned p2 = 0;

    typedef double ValType;
    typedef struct s_item {
      IdxType idx;
      ValType val;
    } s_item;

    unsigned len_first = first_s->nofitems;
    unsigned len_second = second_s->nofitems;
    if(forceDense != 0 || (len_first + len_second) * (sizeof(IdxType) + sizeof(ValType)) >= dim * sizeof(ValType)) {
      // Result has to be dense
      result_s->nofitems = dim;
      ValType * const __restrict__ result = (ValType *)result_s->items;

      if(len_first == dim && len_second == dim) {
        // add both dense
        const ValType * const __restrict__ first = (const ValType *)first_s->items;
        const ValType * const __restrict__ second = (const ValType *)second_s->items;

        #pragma omp simd 
        for(size_t i = 0; i < dim; ++i) {
          result[i] = first[i] + second[i];
        }
      } else if(len_first == dim) {
        // add first dense and second sparse
        const ValType *first = (const ValType *)first_s->items;
        const s_item *second = (const s_item *)second_s->items;
        
        for(size_t i = 0; i < dim; ++i) {
          if(p2 < len_second && second[p2].idx == i) {
            result[i] = first[i] + second[p2].val;
            p2++;
          } else {
            result[i] = first[i];
          }
        }

      } else if(len_second == dim) {
        // add first sparse and second dense
        const s_item *first = (const s_item *)first_s->items;
        const ValType *second = (const ValType *)second_s->items;
        
        for(size_t i = 0; i < dim; ++i) {
          if(p1 < len_first && first[p1].idx == i) {
            result[i] = first[p1].val + second[i];
            p1++;
          } else {
            result[i] = second[i];
          }
        }
      } else {
        // add first sparse and second sparse
        const s_item *first = (const s_item*)first_s->items;
        const s_item *second = (const s_item *)second_s->items;

        #pragma omp simd 
        for(size_t i = 0; i < dim; ++i) {
          result[i] = 0.0;
        }

        // Sum sparse vector
        while(p1 < len_first || p2 < len_second) {
          if((p1 == len_first) || (p2 != len_second && (second[p2].idx < first[p1].idx))) {
            result[second[p2].idx] = second[p2].val;
            p2++;
          } else if((p2 == len_second) || (first[p1].idx < second[p2].idx)) {
            result[first[p1].idx] = first[p1].val;
            p1++;
          } else {
            // index of receiver as index of sender must be equal
            result[first[p1].idx] = first[p1].val + second[p2].val;
            p1++;
            p2++;
          }
        }
      }
    } else {
      // Result will be sparse
      int newLen = 0;
      const s_item *first = (const s_item *)first_s->items;
      const s_item *second = (const s_item *)second_s->items;
      s_item *result = (s_item *)result_s->items;

      // Sum sparse vector
      while(p1 < len_first || p2 < len_second) {
        if((p1 == len_first) || (p2 != len_second && (second[p2].idx < first[p1].idx))) {
          result[newLen].idx = second[p2].idx;
          result[newLen].val = second[p2].val;
          p2++;
        } else if((p2 == len_second) || (first[p1].idx < second[p2].idx)) {
          result[newLen].idx = first[p1].idx;
          result[newLen].val = first[p1].val;
          p1++;
        } else {
          // index of receiver as index of sender must be equal
          result[newLen].idx = first[p1].idx;
          result[newLen].val = first[p1].val + second[p2].val;
          p1++;
          p2++;
        }
        newLen++;
      }

      result_s->nofitems = newLen;
    }
}

void sum_f_streams(const struct stream *first_s, const struct stream *second_s, struct stream *result_s, unsigned dim, int forceDense) {

    unsigned p1 = 0;
    unsigned p2 = 0;

    typedef float ValType;
    typedef struct s_item {
      IdxType idx;
      ValType val;
    } s_item;

    unsigned len_first = first_s->nofitems;
    unsigned len_second = second_s->nofitems;
    if(forceDense != 0 || (len_first + len_second) * (sizeof(IdxType) + sizeof(ValType)) >= dim * sizeof(ValType)) {
      // Result has to be dense
      result_s->nofitems = dim;
      ValType * const __restrict__ result = (ValType *)result_s->items;

      if(len_first == dim && len_second == dim) {
        // add both dense
        const ValType * const __restrict__ first = (const ValType *)first_s->items;
        const ValType * const __restrict__ second = (const ValType *)second_s->items;

        #pragma omp simd 
        for(size_t i = 0; i < dim; ++i) {
          result[i] = first[i] + second[i];
        }
      } else if(len_first == dim) {
        // add first dense and second sparse
        const ValType *first = (const ValType *)first_s->items;
        const s_item *second = (const s_item *)second_s->items;
        
        for(size_t i = 0; i < dim; ++i) {
          if(p2 < len_second && second[p2].idx == i) {
            result[i] = first[i] + second[p2].val;
            p2++;
          } else {
            result[i] = first[i];
          }
        }

      } else if(len_second == dim) {
        // add first sparse and second dense
        const s_item *first = (const s_item *)first_s->items;
        const ValType *second = (const ValType *)second_s->items;
        
        for(size_t i = 0; i < dim; ++i) {
          if(p1 < len_first && first[p1].idx == i) {
            result[i] = first[p1].val + second[i];
            p1++;
          } else {
            result[i] = second[i];
          }
        }
      } else {
        // add first sparse and second sparse
        const s_item *first = (const s_item*)first_s->items;
        const s_item *second = (const s_item *)second_s->items;

        #pragma omp simd 
        for(size_t i = 0; i < dim; ++i) {
          result[i] = 0.0;
        }

        // Sum sparse vector
        while(p1 < len_first || p2 < len_second) {
          if((p1 == len_first) || (p2 != len_second && (second[p2].idx < first[p1].idx))) {
            result[second[p2].idx] = second[p2].val;
            p2++;
          } else if((p2 == len_second) || (first[p1].idx < second[p2].idx)) {
            result[first[p1].idx] = first[p1].val;
            p1++;
          } else {
            // index of receiver as index of sender must be equal
            result[first[p1].idx] = first[p1].val + second[p2].val;
            p1++;
            p2++;
          }
        }
      }
    } else {
      // Result will be sparse
      int newLen = 0;
      const s_item *first = (const s_item *)first_s->items;
      const s_item *second = (const s_item *)second_s->items;
      s_item *result = (s_item *)result_s->items;

      // Sum sparse vector
      while(p1 < len_first || p2 < len_second) {
        if((p1 == len_first) || (p2 != len_second && (second[p2].idx < first[p1].idx))) {
          result[newLen].idx = second[p2].idx;
          result[newLen].val = second[p2].val;
          p2++;
        } else if((p2 == len_second) || (first[p1].idx < second[p2].idx)) {
          result[newLen].idx = first[p1].idx;
          result[newLen].val = first[p1].val;
          p1++;
        } else {
          // index of receiver as index of sender must be equal
          result[newLen].idx = first[p1].idx;
          result[newLen].val = first[p1].val + second[p2].val;
          p1++;
          p2++;
        }
        newLen++;
      }

      result_s->nofitems = newLen;
    }
}

void sum_i_streams(const struct stream *first_s, const struct stream *second_s, struct stream *result_s, unsigned dim, int forceDense) {

    unsigned p1 = 0;
    unsigned p2 = 0;

    typedef int ValType;
    typedef struct s_item {
      IdxType idx;
      ValType val;
    } s_item;

    unsigned len_first = first_s->nofitems;
    unsigned len_second = second_s->nofitems;
    if(forceDense != 0 || (len_first + len_second) * (sizeof(IdxType) + sizeof(ValType)) >= dim * sizeof(ValType)) {
      // Result has to be dense
      result_s->nofitems = dim;
      ValType * const __restrict__ result = (ValType *)result_s->items;

      if(len_first == dim && len_second == dim) {
        // add both dense
        const ValType * const __restrict__ first = (const ValType *)first_s->items;
        const ValType * const __restrict__ second = (const ValType *)second_s->items;

        #pragma omp simd 
        for(size_t i = 0; i < dim; ++i) {
          result[i] = first[i] + second[i];
        }
      } else if(len_first == dim) {
        // add first dense and second sparse
        const ValType *first = (const ValType *)first_s->items;
        const s_item *second = (const s_item *)second_s->items;
        
        for(size_t i = 0; i < dim; ++i) {
          if(p2 < len_second && second[p2].idx == i) {
            result[i] = first[i] + second[p2].val;
            p2++;
          } else {
            result[i] = first[i];
          }
        }

      } else if(len_second == dim) {
        // add first sparse and second dense
        const s_item *first = (const s_item *)first_s->items;
        const ValType *second = (const ValType *)second_s->items;
        
        for(size_t i = 0; i < dim; ++i) {
          if(p1 < len_first && first[p1].idx == i) {
            result[i] = first[p1].val + second[i];
            p1++;
          } else {
            result[i] = second[i];
          }
        }
      } else {
        // add first sparse and second sparse
        const s_item *first = (const s_item*)first_s->items;
        const s_item *second = (const s_item *)second_s->items;

        #pragma omp simd 
        for(size_t i = 0; i < dim; ++i) {
          result[i] = 0.0;
        }

        // Sum sparse vector
        while(p1 < len_first || p2 < len_second) {
          if((p1 == len_first) || (p2 != len_second && (second[p2].idx < first[p1].idx))) {
            result[second[p2].idx] = second[p2].val;
            p2++;
          } else if((p2 == len_second) || (first[p1].idx < second[p2].idx)) {
            result[first[p1].idx] = first[p1].val;
            p1++;
          } else {
            // index of receiver as index of sender must be equal
            result[first[p1].idx] = first[p1].val + second[p2].val;
            p1++;
            p2++;
          }
        }
      }
    } else {
      // Result will be sparse
      int newLen = 0;
      const s_item *first = (const s_item *)first_s->items;
      const s_item *second = (const s_item *)second_s->items;
      s_item *result = (s_item *)result_s->items;

      // Sum sparse vector
      while(p1 < len_first || p2 < len_second) {
        if((p1 == len_first) || (p2 != len_second && (second[p2].idx < first[p1].idx))) {
          result[newLen].idx = second[p2].idx;
          result[newLen].val = second[p2].val;
          p2++;
        } else if((p2 == len_second) || (first[p1].idx < second[p2].idx)) {
          result[newLen].idx = first[p1].idx;
          result[newLen].val = first[p1].val;
          p1++;
        } else {
          // index of receiver as index of sender must be equal
          result[newLen].idx = first[p1].idx;
          result[newLen].val = first[p1].val + second[p2].val;
          p1++;
          p2++;
        }
        newLen++;
      }

      result_s->nofitems = newLen;
    }
}

int NBC_Operation(void *buf3, void *buf1, void *buf2, MPI_Op op, MPI_Datatype type, int count, int forceDense) {
  int i;

  if(count < 0) {
    if(type == MPI_INT) {
      sum_i_streams((struct stream *)buf1, (struct stream *)buf2, (struct stream *)buf3, -1*count, forceDense);
      return NBC_OK;
    } else if(type == MPI_FLOAT) {
      sum_f_streams((struct stream *)buf1, (struct stream *)buf2, (struct stream *)buf3, -1*count, forceDense);
      return NBC_OK;
    } else if(type == MPI_DOUBLE) {
      sum_d_streams((struct stream *)buf1, (struct stream *)buf2, (struct stream *)buf3, -1*count, forceDense);
      return NBC_OK;
    } else {
      return NBC_DATATYPE_NOT_SUPPORTED;
    }
  }
     
  if(type == MPI_INT) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((int*)buf1) + i) > *(((int*)buf2) + i)) *(((int*)buf3) + i) = *(((int*)buf2) + i); else *(((int*)buf3) + i) = *(((int*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((int*)buf1) + i) < *(((int*)buf2) + i)) *(((int*)buf3) + i) = *(((int*)buf2) + i); else *(((int*)buf3) + i) = *(((int*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((int*)buf3) + i) = *(((int*)buf1) + i) + *(((int*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((int*)buf3) + i) = *(((int*)buf1) + i) * *(((int*)buf2) + i); 
      }
    } else if(op == MPI_LAND) {
      for(i=0; i<count; i++) {
        *(((int*)buf3) + i) = *(((int*)buf1) + i) && *(((int*)buf2) + i); 
      }
    } else if(op == MPI_BAND) {
      for(i=0; i<count; i++) {
        *(((int*)buf3) + i) = *(((int*)buf1) + i) & *(((int*)buf2) + i); 
      }
    } else if(op == MPI_LOR) {
      for(i=0; i<count; i++) {
        *(((int*)buf3) + i) = *(((int*)buf1) + i) || *(((int*)buf2) + i); 
      }
    } else if(op == MPI_BOR) {
      for(i=0; i<count; i++) {
        *(((int*)buf3) + i) = *(((int*)buf1) + i) | *(((int*)buf2) + i); 
      }
    } else if(op == MPI_LXOR) {
      for(i=0; i<count; i++) {
        *(((int*)buf3) + i) = ((*(((int*)buf1) + i) ? 1 : 0) ^ (*(((int*)buf2) + i) ?  1 : 0)); 
      }
    } else if(op == MPI_BXOR) {
      for(i=0; i<count; i++) {
        *(((int*)buf3) + i) = ((*(((int*)buf1) + i)) ^ (*(((int*)buf2) + i))); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_LONG) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((long*)buf1) + i) > *(((long*)buf2) + i)) *(((long*)buf3) + i) = *(((long*)buf2) + i); else *(((long*)buf3) + i) = *(((long*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((long*)buf1) + i) < *(((long*)buf2) + i)) *(((long*)buf3) + i) = *(((long*)buf2) + i); else *(((long*)buf3) + i) = *(((long*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((long*)buf3) + i) = *(((long*)buf1) + i) + *(((long*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((long*)buf3) + i) = *(((long*)buf1) + i) * *(((long*)buf2) + i); 
      }
    } else if(op == MPI_LAND) {
      for(i=0; i<count; i++) {
        *(((long*)buf3) + i) = *(((long*)buf1) + i) && *(((long*)buf2) + i); 
      }
    } else if(op == MPI_BAND) {
      for(i=0; i<count; i++) {
        *(((long*)buf3) + i) = *(((long*)buf1) + i) & *(((long*)buf2) + i); 
      }
    } else if(op == MPI_LOR) {
      for(i=0; i<count; i++) {
        *(((long*)buf3) + i) = *(((long*)buf1) + i) || *(((long*)buf2) + i); 
      }
    } else if(op == MPI_BOR) {
      for(i=0; i<count; i++) {
        *(((long*)buf3) + i) = *(((long*)buf1) + i) | *(((long*)buf2) + i); 
      }
    } else if(op == MPI_LXOR) {
      for(i=0; i<count; i++) {
        *(((long*)buf3) + i) = ((*(((long*)buf1) + i) ? 1 : 0) ^ (*(((long*)buf2) + i) ?  1 : 0)); 
      }
    } else if(op == MPI_BXOR) {
      for(i=0; i<count; i++) {
        *(((long*)buf3) + i) = ((*(((long*)buf1) + i)) ^ (*(((long*)buf2) + i))); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_SHORT) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((short*)buf1) + i) > *(((short*)buf2) + i)) *(((short*)buf3) + i) = *(((short*)buf2) + i); else *(((short*)buf3) + i) = *(((short*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((short*)buf1) + i) < *(((short*)buf2) + i)) *(((short*)buf3) + i) = *(((short*)buf2) + i); else *(((short*)buf3) + i) = *(((short*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((short*)buf3) + i) = *(((short*)buf1) + i) + *(((short*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((short*)buf3) + i) = *(((short*)buf1) + i) * *(((short*)buf2) + i); 
      }
    } else if(op == MPI_LAND) {
      for(i=0; i<count; i++) {
        *(((short*)buf3) + i) = *(((short*)buf1) + i) && *(((short*)buf2) + i); 
      }
    } else if(op == MPI_BAND) {
      for(i=0; i<count; i++) {
        *(((short*)buf3) + i) = *(((short*)buf1) + i) & *(((short*)buf2) + i); 
      }
    } else if(op == MPI_LOR) {
      for(i=0; i<count; i++) {
        *(((short*)buf3) + i) = *(((short*)buf1) + i) || *(((short*)buf2) + i); 
      }
    } else if(op == MPI_BOR) {
      for(i=0; i<count; i++) {
        *(((short*)buf3) + i) = *(((short*)buf1) + i) | *(((short*)buf2) + i); 
      }
    } else if(op == MPI_LXOR) {
      for(i=0; i<count; i++) {
        *(((short*)buf3) + i) = ((*(((short*)buf1) + i) ? 1 : 0) ^ (*(((short*)buf2) + i) ?  1 : 0)); 
      }
    } else if(op == MPI_BXOR) {
      for(i=0; i<count; i++) {
        *(((short*)buf3) + i) = ((*(((short*)buf1) + i)) ^ (*(((short*)buf2) + i))); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_UNSIGNED) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((unsigned int*)buf1) + i) > *(((unsigned int*)buf2) + i)) *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf2) + i); else *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((unsigned int*)buf1) + i) < *(((unsigned int*)buf2) + i)) *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf2) + i); else *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf1) + i) + *(((unsigned int*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf1) + i) * *(((unsigned int*)buf2) + i); 
      }
    } else if(op == MPI_LAND) {
      for(i=0; i<count; i++) {
        *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf1) + i) && *(((unsigned int*)buf2) + i); 
      }
    } else if(op == MPI_BAND) {
      for(i=0; i<count; i++) {
        *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf1) + i) & *(((unsigned int*)buf2) + i); 
      }
    } else if(op == MPI_LOR) {
      for(i=0; i<count; i++) {
        *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf1) + i) || *(((unsigned int*)buf2) + i); 
      }
    } else if(op == MPI_BOR) {
      for(i=0; i<count; i++) {
        *(((unsigned int*)buf3) + i) = *(((unsigned int*)buf1) + i) | *(((unsigned int*)buf2) + i); 
      }
    } else if(op == MPI_LXOR) {
      for(i=0; i<count; i++) {
        *(((unsigned int*)buf3) + i) = ((*(((unsigned int*)buf1) + i) ? 1 : 0) ^ (*(((unsigned int*)buf2) + i) ?  1 : 0)); 
      }
    } else if(op == MPI_BXOR) {
      for(i=0; i<count; i++) {
        *(((unsigned int*)buf3) + i) = ((*(((unsigned int*)buf1) + i)) ^ (*(((unsigned int*)buf2) + i))); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_UNSIGNED_LONG) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((unsigned long*)buf1) + i) > *(((unsigned long*)buf2) + i)) *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf2) + i); else *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((unsigned long*)buf1) + i) < *(((unsigned long*)buf2) + i)) *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf2) + i); else *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf1) + i) + *(((unsigned long*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf1) + i) * *(((unsigned long*)buf2) + i); 
      }
    } else if(op == MPI_LAND) {
      for(i=0; i<count; i++) {
        *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf1) + i) && *(((unsigned long*)buf2) + i); 
      }
    } else if(op == MPI_BAND) {
      for(i=0; i<count; i++) {
        *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf1) + i) & *(((unsigned long*)buf2) + i); 
      }
    } else if(op == MPI_LOR) {
      for(i=0; i<count; i++) {
        *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf1) + i) || *(((unsigned long*)buf2) + i); 
      }
    } else if(op == MPI_BOR) {
      for(i=0; i<count; i++) {
        *(((unsigned long*)buf3) + i) = *(((unsigned long*)buf1) + i) | *(((unsigned long*)buf2) + i); 
      }
    } else if(op == MPI_LXOR) {
      for(i=0; i<count; i++) {
        *(((unsigned long*)buf3) + i) = ((*(((unsigned long*)buf1) + i) ? 1 : 0) ^ (*(((unsigned long*)buf2) + i) ?  1 : 0)); 
      }
    } else if(op == MPI_BXOR) {
      for(i=0; i<count; i++) {
        *(((unsigned long*)buf3) + i) = ((*(((unsigned long*)buf1) + i)) ^ (*(((unsigned long*)buf2) + i))); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_UNSIGNED_SHORT) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((unsigned short*)buf1) + i) > *(((unsigned short*)buf2) + i)) *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf2) + i); else *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((unsigned short*)buf1) + i) < *(((unsigned short*)buf2) + i)) *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf2) + i); else *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf1) + i) + *(((unsigned short*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf1) + i) * *(((unsigned short*)buf2) + i); 
      }
    } else if(op == MPI_LAND) {
      for(i=0; i<count; i++) {
        *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf1) + i) && *(((unsigned short*)buf2) + i); 
      }
    } else if(op == MPI_BAND) {
      for(i=0; i<count; i++) {
        *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf1) + i) & *(((unsigned short*)buf2) + i); 
      }
    } else if(op == MPI_LOR) {
      for(i=0; i<count; i++) {
        *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf1) + i) || *(((unsigned short*)buf2) + i); 
      }
    } else if(op == MPI_BOR) {
      for(i=0; i<count; i++) {
        *(((unsigned short*)buf3) + i) = *(((unsigned short*)buf1) + i) | *(((unsigned short*)buf2) + i); 
      }
    } else if(op == MPI_LXOR) {
      for(i=0; i<count; i++) {
        *(((unsigned short*)buf3) + i) = ((*(((unsigned short*)buf1) + i) ? 1 : 0) ^ (*(((unsigned short*)buf2) + i) ?  1 : 0)); 
      }
    } else if(op == MPI_BXOR) {
      for(i=0; i<count; i++) {
        *(((unsigned short*)buf3) + i) = ((*(((unsigned short*)buf1) + i)) ^ (*(((unsigned short*)buf2) + i))); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_FLOAT) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((float*)buf1) + i) > *(((float*)buf2) + i)) *(((float*)buf3) + i) = *(((float*)buf2) + i); else *(((float*)buf3) + i) = *(((float*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((float*)buf1) + i) < *(((float*)buf2) + i)) *(((float*)buf3) + i) = *(((float*)buf2) + i); else *(((float*)buf3) + i) = *(((float*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((float*)buf3) + i) = *(((float*)buf1) + i) + *(((float*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((float*)buf3) + i) = *(((float*)buf1) + i) * *(((float*)buf2) + i); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_DOUBLE) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((double*)buf1) + i) > *(((double*)buf2) + i)) *(((double*)buf3) + i) = *(((double*)buf2) + i); else *(((double*)buf3) + i) = *(((double*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((double*)buf1) + i) < *(((double*)buf2) + i)) *(((double*)buf3) + i) = *(((double*)buf2) + i); else *(((double*)buf3) + i) = *(((double*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((double*)buf3) + i) = *(((double*)buf1) + i) + *(((double*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((double*)buf3) + i) = *(((double*)buf1) + i) * *(((double*)buf2) + i); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_LONG_DOUBLE) { 
    if(op == MPI_MIN) {
      for(i=0; i<count; i++) {
        if(*(((long double*)buf1) + i) > *(((long double*)buf2) + i)) *(((long double*)buf3) + i) = *(((long double*)buf2) + i); else *(((long double*)buf3) + i) = *(((long double*)buf1) + i); 
      }
    } else if(op == MPI_MAX) {
      for(i=0; i<count; i++) {
        if(*(((long double*)buf1) + i) < *(((long double*)buf2) + i)) *(((long double*)buf3) + i) = *(((long double*)buf2) + i); else *(((long double*)buf3) + i) = *(((long double*)buf1) + i); 
      }
    } else if(op == MPI_SUM) {
      for(i=0; i<count; i++) {
        *(((long double*)buf3) + i) = *(((long double*)buf1) + i) + *(((long double*)buf2) + i); 
      }
    } else if(op == MPI_PROD) {
      for(i=0; i<count; i++) {
        *(((long double*)buf3) + i) = *(((long double*)buf1) + i) * *(((long double*)buf2) + i); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_BYTE) { 
    if(op == MPI_BAND) {
      for(i=0; i<count; i++) {
        *(((char*)buf3) + i) = *(((char*)buf1) + i) & *(((char*)buf2) + i); 
      }
    } else if(op == MPI_BOR) {
      for(i=0; i<count; i++) {
        *(((char*)buf3) + i) = *(((char*)buf1) + i) | *(((char*)buf2) + i); 
      }
    } else if(op == MPI_BXOR) {
      for(i=0; i<count; i++) {
        *(((char*)buf3) + i) = ((*(((char*)buf1) + i)) ^ (*(((char*)buf2) + i))); 
      }
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_FLOAT_INT) { 
    if(op == MPI_MAXLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          float val;
          int rank;
        } float_int;
        float_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((float_int*)buf1) + i;
        ptr2 = ((float_int*)buf2) + i;
        ptr3 = ((float_int*)buf3) + i;
      
        if(ptr1->val < ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else if(op == MPI_MINLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          float val;
          int rank;
        } float_int;
        float_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((float_int*)buf1) + i;
        ptr2 = ((float_int*)buf2) + i;
        ptr3 = ((float_int*)buf3) + i;
      
        if(ptr1->val > ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_DOUBLE_INT) { 
    if(op == MPI_MAXLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          double val;
          int rank;
        } double_int;
        double_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((double_int*)buf1) + i;
        ptr2 = ((double_int*)buf2) + i;
        ptr3 = ((double_int*)buf3) + i;
      
        if(ptr1->val < ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else if(op == MPI_MINLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          double val;
          int rank;
        } double_int;
        double_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((double_int*)buf1) + i;
        ptr2 = ((double_int*)buf2) + i;
        ptr3 = ((double_int*)buf3) + i;
      
        if(ptr1->val > ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_LONG_INT) { 
    if(op == MPI_MAXLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          long val;
          int rank;
        } long_int;
        long_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((long_int*)buf1) + i;
        ptr2 = ((long_int*)buf2) + i;
        ptr3 = ((long_int*)buf3) + i;
      
        if(ptr1->val < ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else if(op == MPI_MINLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          long val;
          int rank;
        } long_int;
        long_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((long_int*)buf1) + i;
        ptr2 = ((long_int*)buf2) + i;
        ptr3 = ((long_int*)buf3) + i;
      
        if(ptr1->val > ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_2INT) { 
    if(op == MPI_MAXLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          int val;
          int rank;
        } int_int;
        int_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((int_int*)buf1) + i;
        ptr2 = ((int_int*)buf2) + i;
        ptr3 = ((int_int*)buf3) + i;
      
        if(ptr1->val < ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else if(op == MPI_MINLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          int val;
          int rank;
        } int_int;
        int_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((int_int*)buf1) + i;
        ptr2 = ((int_int*)buf2) + i;
        ptr3 = ((int_int*)buf3) + i;
      
        if(ptr1->val > ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_SHORT_INT) { 
    if(op == MPI_MAXLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          short val;
          int rank;
        } short_int;
        short_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((short_int*)buf1) + i;
        ptr2 = ((short_int*)buf2) + i;
        ptr3 = ((short_int*)buf3) + i;
      
        if(ptr1->val < ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else if(op == MPI_MINLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          short val;
          int rank;
        } short_int;
        short_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((short_int*)buf1) + i;
        ptr2 = ((short_int*)buf2) + i;
        ptr3 = ((short_int*)buf3) + i;
      
        if(ptr1->val > ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else return NBC_OP_NOT_SUPPORTED; 
  } else if(type == MPI_LONG_DOUBLE_INT) { 
    if(op == MPI_MAXLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          long double val;
          int rank;
        } long_double_int;
        long_double_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((long_double_int*)buf1) + i;
        ptr2 = ((long_double_int*)buf2) + i;
        ptr3 = ((long_double_int*)buf3) + i;
      
        if(ptr1->val < ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else if(op == MPI_MINLOC) {
      for(i=0; i<count; i++) {
        typedef struct {
          long double val;
          int rank;
        } long_double_int;
        long_double_int *ptr1, *ptr2, *ptr3;
                            
        ptr1 = ((long_double_int*)buf1) + i;
        ptr2 = ((long_double_int*)buf2) + i;
        ptr3 = ((long_double_int*)buf3) + i;
      
        if(ptr1->val > ptr2->val) { 
          ptr3->val = ptr2->val; ptr3->rank = ptr2->rank; 
        } else { 
          ptr3->val = ptr1->val; ptr3->rank = ptr1->rank; 
        } 
      }  
    } else return NBC_OP_NOT_SUPPORTED; 
  } else return NBC_DATATYPE_NOT_SUPPORTED;
  
  return NBC_OK;
}
